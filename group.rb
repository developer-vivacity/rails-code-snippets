class Group < ActiveRecord::Base
 
  has_many :users  #multiple users for a single group
  has_and_belongs_to_many :stack_templates #many to many relationship with another class

  validates :maximum_stack_limit, presence: true #field maximum_stack_limit can't be blank

  validates :name, presence: true #name field can't be blank

  validates :invite_code, presence: true #invite_code field can't be blank

  validates_uniqueness_of :invite_code, :name #validates the uniqueness of invite_code with name

  belongs_to :class_project #defines which class project this group is associalted with



  include PgSearch #included pgsearch to enable searching, multi-search and search scopes

  #multisearch with name,invite code and scheduled timezone
  multisearchable against: %i(name invite_code schd_timzone)

  #update the document with pg search result
  def self.rebuild_pg_search_documents
    find_each { |record| record.update_pg_search_document }
  end

  #invite_code generated by calling generate_token function
  def generate_invite_code
     self.invite_code = generate_token
  end

  #current status either its active or inactive
  def current_status
      status ? 'Active' : 'Inactive'
  end

  #maximum_user_size function for checking class has reached to maximum user limit or not
  def self.maximum_user_size
    if self.users.length <= self.maximum_number_of_users
    return true
    else
    errors[:base] << "Maximum number of limit reached in this class"
    return false
    end 
  end

  # to destroy the stack of the user if exist
  def will_expire_on
    cfm = AWS::CloudFormation.new # calling aws cloudformation api
    if self.users.length > 0 # users length is more then 0
       self.users.each do |user| 
         if user.stacks.length > 0
           user.stacks.each do |stack|
           stackaws = cfm.stacks["#{stack.stack_name}"] # get that stack from aws 
            if stackaws.exists? 
              stackaws.delete # delete that aws stack
              sleep (1) # delay or sleep for 1 second
            end
            stack.destroy # delete that stack now from database
           end
         end
       end
    end	
  end



  #it will use to always run in the background and calling the function will_expire_on
  handle_asynchronously :will_expire_on, :run_at => Proc.new {|p| p.will_expires_on }

  #adding the users when importing by csv
  def self.import(file,group_id)
      invalid_emails = []
      CSV.foreach(file.path, headers: true) do |row|
        user_hash = row.to_hash # exclude the price field
        user_hash[:group_id] = group_id
        user_hash[:request_for_group] = true
        if user_hash["password"].blank? or user_hash["password"].nil?
        random_password = SecureRandom.urlsafe_base64(nil, false)
        user_hash[:password] = random_password
        user_hash[:password_confirmation] = random_password
        else
        user_hash[:password_confirmation] = user_hash["password"]
        end
        @user = User.where(email: user_hash["email"])
        if @user.count == 1
          @user.first.update_attributes(user_hash)
        else
          # I would also change the finds with some id (constant) for speedup 
           @user = User.new(user_hash)
            if @user.valid?
            @user.save
            WelcomeStudentMailer.welcome_email(@user,user_hash["password"]).deliver_now 
            else
              invalid_emails << user_hash["email"]
              invalid_emails << @user.errors.full_messages
            end
        end 
      end 
      return invalid_emails
  end




  # starting up the job on aws(daily basis)
  def startup(group)
      cfmstartup = AWS::CloudFormation.new # call cloudformation
      ec2startup = AWS::EC2.new # call ec2
      # long running method
      puts "XXXXXXXXXX DAILY CHECKING HERE STARUP XXXXXXXXXXXX"
      puts  group.name
      puts "Start up Job is working now"
               if group.users.length > 0
                 allinstanceids = []
                  group.users.each do |user|
                    if user.stacks.length > 0
                    user.stacks.each do |stack|
                      if stack.ec2instance_ids.length > 0 
                      allinstanceids.concat stack.ec2instance_ids # concatinate all instance ids with ec2 instance ids of stack
                      end
                    end
                  end
                end
                p allinstanceids = allinstanceids.uniq
                if allinstanceids.length > 0
                 $ec2_resource.instances({instance_ids: allinstanceids}).batch_start # start the jobs
                end
              end 
      puts "XXXXXXXXXXXXXXXXXXXXXX"
    end

    # shutting down the job on aws(daily basis)
    def shutdown(group)
      cfmshutdown = AWS::CloudFormation.new
      ec2shutdown = AWS::EC2.new
      puts "XXXXXXXXXX DAILY CHECKING HERE SHUT DOWN XXXXXXXXXXXX"
      puts  group.name
      puts "Shut down Job is working now"
      puts group.users.length
      puts "-------------"
          if group.users.length > 0
            allinstanceids = []
              group.users.each do |user|
                if user.stacks.length > 0
                  user.stacks.each do |stack|
                    if stack.ec2instance_ids.length > 0 
                    allinstanceids.concat stack.ec2instance_ids
                    end
                  end
                end
              end
            puts "BUBBBUBUBBBB"
            puts allinstanceids.class
            allinstanceids = allinstanceids.uniq
            puts allinstanceids.class
            puts "BUBBBUBUBBBB"
            if allinstanceids.length > 0
             $ec2_resource.instances({instance_ids: allinstanceids}).batch_stop # To job stop
            end
          end 
      puts "YYYYYYYYYYYYYYYYYYYYYYYY"
    end



    # to run startup and shutdown methods in background
    handle_asynchronously :startup
    handle_asynchronously :shutdown

   protected
    # generates a secure random token with base 64 encoding
    def generate_token
      loop do
        random_token = SecureRandom.urlsafe_base64(nil, false)
        break random_token unless self.class.exists?(invite_code: random_token)
      end
    end


end
